MODULE PARAMETERS
! MODULE WITH THE PARAMETERS NEEDED IN THE SIMULATION
! PEDRO OJEDA,  07/MAY/2011

IMPLICIT NONE
INTEGER, PARAMETER  :: NUM_RES=30                       !NUMBER OF AMINOACIDS IN EACH SEQUENCE
INTEGER, PARAMETER  :: K4B=SELECTED_INT_KIND(9)
INTEGER, PARAMETER  :: DP = SELECTED_REAL_KIND(12, 60)
INTEGER, PARAMETER  :: TIME=90000                        !TIME OF SIMULATION
INTEGER, SAVE       :: NSTEP
INTEGER             :: CLASE(NUM_RES)                   !SEQUENCES OF AMINOACIDS
INTEGER             :: I,J,K,L,M
INTEGER, PARAMETER  :: SECU=0                           !THE NUMBER OF SEQUENCE                            
REAL(DP),PARAMETER  :: PI=3.141592653589793D0
REAL(DP),PARAMETER  :: DT=0.0001D0                       !TIME STEP
REAL(DP)            :: DT2=DT*DT                        !TIME STEP SQUARED
REAL(DP)            :: DTP5=0.5D0*DT                    !TIME STEP HALFED
REAL(DP),PARAMETER  :: BOXL=100.0D0                     !BOX SIZE=BOXL 
REAL(DP),PARAMETER  :: GAMMA=1.0                        !GAMMA=6.5*6.0*PI FROM STOKES LAW 
REAL(DP),PARAMETER  :: TEMP1=9000.0D0 , TEMP2=500.0D0       !TWO TEMPERATURES OF THE SYSTEM
REAL(DP),PARAMETER  :: KBT_CONST = 0.5D0                  ! KB * T 
REAL(DP)            :: BOXI                             !1.0/BOXL 
REAL(DP)            :: EPS_CONST(4,4)                   !ARRAY FOR EPSILON
REAL(DP)            :: SIGMA_CONST(NUM_RES,NUM_RES)     !ARRAY OF SIGMA
CHARACTER*1         :: AMINO(4)=(/'S','C','P','N'/)     !ALPHABET OF FOUR LETTERS        
REAL(DP)            :: POT_ENER
REAL(DP)            :: KIN_ENER


INTEGER,SAVE        :: O = 1, N = 1

REAL(DP)            :: XDIS(NUM_RES,NUM_RES),YDIS(NUM_RES,NUM_RES),ZDIS(NUM_RES,NUM_RES)
REAL(DP)            :: DIS(NUM_RES,NUM_RES),RDN(NUM_RES,3)




!PARAMETERS FOR THE BERENDSEN THERMOSTAT
REAL(DP)            :: LAMBDA_BERENDSEN
REAL(DP)            :: TEMP
REAL(DP),PARAMETER  :: N_F = 3.0D0*NUM_RES-3.0D0, TAU = 1.0D0 
REAL(DP), SAVE      :: TEMP0 


TYPE PARTICLE_STRUCTURE
REAL(DP)            :: COORX(2),COORY(2),COORZ(2)
REAL(DP)            :: VELX(2),VELY(2),VELZ(2)
REAL(DP)            :: GRADX(2),GRADY(2),GRADZ(2)
REAL(DP)            :: MASS
REAL(DP)            :: CHARGE
REAL(DP)            :: INERTIA
END TYPE PARTICLE_STRUCTURE


TYPE (PARTICLE_STRUCTURE), SAVE, DIMENSION(NUM_RES) :: PARTICLE
!TYPE (PARTICLE_STRUCTURE), SAVE, DIMENSION(NUM_RES) :: PARTICLE_BACKUP
TYPE (PARTICLE_STRUCTURE), SAVE, DIMENSION(NUM_RES) :: PARTICLE_FOLDED

END MODULE PARAMETERS



!MODULE WL_MODULE
!
!! MODULE FOR THE PARAMETERS AND VARIABLES USED BY THE WANG-LANDAU METHOD
!INTEGER, PARAMETER       :: DP = SELECTED_REAL_KIND(12, 60)
!INTEGER, PARAMETER       :: E_MIN = -20000 , E_MAX = 0
!INTEGER                  :: E_BIN
!INTEGER,SAVE             :: E_BIN_OLD, E_BIN_NEW
!REAL(DP), SAVE           :: T_HIST( E_MIN : E_MAX ), ALPHA( E_MIN : E_MAX ), DOS( E_MIN : E_MAX )
!REAL(DP), SAVE           :: CUM_HIST( E_MIN : E_MAX ), VISITS( E_MIN : E_MAX )
!REAL(DP), SAVE           :: GAUSSIAN( -40 : 40 ) 
!REAL(DP), PARAMETER      :: DELTA_ENER = 0.1D0
!REAL(DP), SAVE           :: FACT_F                                   ! LOG(F) = MODIFICATION FACTOR
!REAL(DP), SAVE           :: DF 
!REAL(DP), SAVE           :: SCALE_WL 
!REAL(DP), SAVE           :: OMEGA
!LOGICAL,SAVE             :: ACCEPT 
!INTEGER, SAVE            :: INDICE
!INTEGER, SAVE            :: INTERV_SIZE
!
!END MODULE WL_MODULE




PROGRAM MOLECULAR_DYNAMICS

! MAIN PROGRAM TO RUN THE MOLECULAR DYNAMICS
! PEDRO OJEDA,  07/MAY/2011

USE PARAMETERS
USE Ziggurat
REAL                :: T1, T2,TT1, TT2
INTEGER             :: IMAC
INTEGER             :: P
INTEGER             :: TMP


REAL(DP)            :: ENER
!REAL(DP)            :: HIST(-2000:2000),TRANS(-2000:0,-2000:0),CMX,CMY,CMZ
!INTEGER	            :: OBIN,EBIN,NEBIN

CHARACTER*40 NAME
CHARACTER*40 NAME4


	IMAC=-35000
        CALL ZIGSET( IMAC )


!READ THE SEQUENCE
        IF(SECU.LT.10) THEN
	   WRITE(NAME4,"('sec_',i1,'.dat')")SECU
        ELSE
	  WRITE(NAME4,"('sec_',i2,'.dat')")SECU
        ENDIF
        OPEN(55,FILE=NAME4,STATUS='UNKNOWN')
	    DO P=1,NUM_RES
		READ(55,*)	CLASE(P)
	    ENDDO
        CLOSE(55)


!ASSIGN THE VALUES FOR THE EPSILONS AND SIGMAS
        CALL SECUENCIAS

        CALL INITIALIZE

        OPEN(88,FILE='min_0.dat',STATUS='UNKNOWN')
                   DO P=1,NUM_RES
                        READ(88,*) PARTICLE(P)%COORX(1),&
                        PARTICLE(P)%COORY(1),PARTICLE(P)%COORZ(1)
                   ENDDO
        CLOSE(88)

        CALL FORCES

!        write(6,*) 'Potential Energy', POT_ENER
!        write(6,*) 'N=', N

!        DO P=1,NUM_RES
!             WRITE(6,*) PARTICLE(P)%GRADX(N),&
!             PARTICLE(P)%GRADY(N),PARTICLE(P)%GRADZ(N)
!        ENDDO
!        stop

        OPEN(88,FILE='KOORDINATEN_1T.xyz',STATUS='UNKNOWN')

!                   WRITE(88,*) NUM_RES
!                   WRITE(88,*) '  '
!                   DO P=1,NUM_RES
!                        WRITE(88,*) 'C', 0.25*PARTICLE(P)%COOR(1),&
!                        0.25*PARTICLE(P)%COOR(2),0.25*PARTICLE(P)%COOR(3)
!                   ENDDO


!MAIN PART OF MOLECULAR DINAMICS
        N = 2
        DO NSTEP=1,60000
!
!!               CALL WRITE_COOR
!               CALL UPDATE_COOR_LEAP_FROG_BERENDSEN
               CALL FORCES
!             WRITE(6,*) PARTICLE(1)%GRADX(O),PARTICLE(1)%GRADY(O),PARTICLE(1)%GRADZ(O)
               CALL UPDATE_VEL_VERLET
        write(6,*) POT_ENER, KIN_ENER, POT_ENER + KIN_ENER

               TMP = O
               O = N 
               N = TMP

!
!               IF(MOD(NSTEP,100000).EQ.0) THEN
!
!                   WRITE(6,*) TEMP, POT_ENER
!
!                   WRITE(88,*) NUM_RES
!                   WRITE(88,*) '  '
!                   DO P=1,NUM_RES
!                        WRITE(88,*) 'C', 0.25*PARTICLE_FOLDED(P)%COOR(1), &
!                        0.25*PARTICLE_FOLDED(P)%COOR(2),0.25*PARTICLE_FOLDED(P)%COOR(3)
!                   ENDDO
!               ENDIF
!
!               IF(MOD(NSTEP,10000000) .EQ. 0 ) THEN
!                      CALL WRITE_WANG_LANDAU_MD_HIST
!                      CALL RE_INITIALIZE
!               ENDIF
!
!               IF(FACT_F < 0.0004) THEN
!                     IF(MOD(NSTEP,3000000) .EQ. 0 ) THEN
!                      !CALL WRITE_WANG_LANDAU_MD_HIST
!                         CALL RE_INITIALIZE
!                     ENDIF
!               ENDIF
!
	 ENDDO
        CLOSE(88)

!         Activate WL sampling
!         CALL WRITE_WANG_LANDAU_MD_HIST

END PROGRAM MOLECULAR_DYNAMICS


SUBROUTINE UPDATE_VEL_VERLET

! SUBROUTINE TO UPDATE THE VELOCITIES BY MEANS OF THE VELOCITY VERLET ALGORITHM
! PEDRO OJEDA,  17/SEP/2021
USE PARAMETERS
INTEGER             :: P


	    DO P=1,NUM_RES
		    PARTICLE(P)%COORX(N) = PARTICLE(P)%COORX(O) + DT*PARTICLE(P)%VELX(O) + &
		    0.5D0*DT2*PARTICLE(P)%GRADX(O) 
		    PARTICLE(P)%COORY(N) = PARTICLE(P)%COORY(O) + DT*PARTICLE(P)%VELY(O) + &
		    0.5D0*DT2*PARTICLE(P)%GRADY(O) 
		    PARTICLE(P)%COORZ(N) = PARTICLE(P)%COORZ(O) + DT*PARTICLE(P)%VELZ(O) + &
		    0.5D0*DT2*PARTICLE(P)%GRADZ(O) 
            ENDDO

	    DO P=1,NUM_RES
		    PARTICLE(P)%VELX(N) = PARTICLE(P)%VELX(O) + DTP5 * ( PARTICLE(P)%GRADX(N) + PARTICLE(P)%GRADX(O) )
		    PARTICLE(P)%VELY(N) = PARTICLE(P)%VELY(O) + DTP5 * ( PARTICLE(P)%GRADY(N) + PARTICLE(P)%GRADY(O) )
		    PARTICLE(P)%VELZ(N) = PARTICLE(P)%VELZ(O) + DTP5 * ( PARTICLE(P)%GRADZ(N) + PARTICLE(P)%GRADZ(O) )
            ENDDO

END SUBROUTINE UPDATE_VEL_VERLET


SUBROUTINE LENNARD_JONES 
! SUBROUTINE TO COMPUTE THE LENNARD-JONES POTENTIAL AND FORCE
! PEDRO OJEDA,  07/MAY/2011

USE PARAMETERS
REAL(DP)            :: FDUMMY1,FDUMMY2,FDUMMY4,FDUMMY5
REAL(DP)            :: FDUMMYD,FDUMMYE
REAL(DP)            :: FTERM
REAL(DP)            :: ENER1
REAL(DP)            :: DISX,DISY,DISZ,DISD


	ENER1=0.0D0

!VAN DER WAALS CONTRIBUTION
DO I=1,NUM_RES-2
     DO J=I+2,NUM_RES

    DISX=PARTICLE(I)%COORX(1)-PARTICLE(J)%COORX(1)                          
    DISY=PARTICLE(I)%COORY(1)-PARTICLE(J)%COORY(1)                          
    DISZ=PARTICLE(I)%COORZ(1)-PARTICLE(J)%COORZ(1)                           
    DISD=DISX*DISX + DISY*DISY + DISZ*DISZ        


           FDUMMY1=SIGMA_CONST(I,J)*SIGMA_CONST(I,J)/DISD
           K=CLASE(I)
           L=CLASE(J)
	   FDUMMY2=FDUMMY1*FDUMMY1                             ! POWER 4
	   FDUMMY4=FDUMMY2*FDUMMY1                             ! POWER 6
	   FDUMMY5=FDUMMY4*FDUMMY4                             ! POWER 12
	   FDUMMYD=1.0/DISD                                    ! 1/DISTANCE_IJ^2
	   FDUMMYE=FDUMMY5-FDUMMY4                             ! (SIGMA/R)^12 - (SIGMA/R)^6
	   ENER1=ENER1+EPS_CONST(K,L)*FDUMMYE                  ! ENERGY = EPSILON*[(SIGMA/R)^12 - (SIGMA/R)^6 ]
	   FTERM=(12.*FDUMMY5-6.*FDUMMY4)*FDUMMYD              ! FORCE = -DV/DR = [12*(SIGMA/R)^12 - 6*(SIGMA/R)^6 ]*(1/R^2)

           PARTICLE(I)%GRADX(1)=PARTICLE(I)%GRADX(1)+EPS_CONST(K,L)*FTERM*DISX   ! X COMPONENT OF THE GRADIENT
           PARTICLE(I)%GRADY(1)=PARTICLE(I)%GRADY(1)+EPS_CONST(K,L)*FTERM*DISY   ! Y COMPONENT OF THE GRADIENT
           PARTICLE(I)%GRADZ(1)=PARTICLE(I)%GRADZ(1)+EPS_CONST(K,L)*FTERM*DISZ   ! Z COMPONENT OF THE GRADIENT
           PARTICLE(J)%GRADX(1)=PARTICLE(J)%GRADX(1)-EPS_CONST(K,L)*FTERM*DISX   ! X COMPONENT OF THE GRADIENT
           PARTICLE(J)%GRADY(1)=PARTICLE(J)%GRADY(1)-EPS_CONST(K,L)*FTERM*DISY   ! Y COMPONENT OF THE GRADIENT
           PARTICLE(J)%GRADZ(1)=PARTICLE(J)%GRADZ(1)-EPS_CONST(K,L)*FTERM*DISZ   ! Z COMPONENT OF THE GRADIENT

     ENDDO

ENDDO

POT_ENER = POT_ENER + ENER1

END SUBROUTINE LENNARD_JONES


SUBROUTINE SPRING 
! SUBROUTINE TO COMPUTE THE HARMONIC OSCILLATOR POTENTIAL AND FORCE
! PEDRO OJEDA,  07/MAY/2011

USE PARAMETERS

REAL(DP)            :: FDUMMY1,FDUMMY2,FDUMMY3,FDUMMY4,FDUMMY5
REAL(DP)            :: FDUMMY0,FDUMMYD,FDUMMYE
REAL(DP)            :: FTERM
REAL(DP)            :: ENER2,ENER
REAL(DP)            :: R_CERO,A_CONST
REAL(DP)            :: DISX,DISY,DISZ,DISPX,DISD,DISPY,DISPZ,DISPD



	R_CERO=3.8D0
	A_CONST=50.0D0
	ENER2=0.0D0


!HARMONIC POTENTIAL
FDUMMY3=2.0D0*A_CONST

DO I=2,NUM_RES-1

    DISX=PARTICLE(I)%COORX(1)-PARTICLE(I+1)%COORX(1)                          
    DISY=PARTICLE(I)%COORY(1)-PARTICLE(I+1)%COORY(1)                          
    DISZ=PARTICLE(I)%COORZ(1)-PARTICLE(I+1)%COORZ(1)                           
    DISD=SQRT(DISX*DISX + DISY*DISY + DISZ*DISZ)        

    DISPX=PARTICLE(I)%COORX(1)-PARTICLE(I-1)%COORX(1)                          
    DISPY=PARTICLE(I)%COORY(1)-PARTICLE(I-1)%COORY(1)                          
    DISPZ=PARTICLE(I)%COORZ(1)-PARTICLE(I-1)%COORZ(1)                           
    DISPD=SQRT(DISPX*DISPX + DISPY*DISPY + DISPZ*DISPZ)       

      FDUMMY1=(DISD-R_CERO)
      FDUMMY2=FDUMMY1*FDUMMY1
      ENER2=ENER2+FDUMMY2
      FDUMMY4=(DISPD-R_CERO)
      PARTICLE(I)%GRADX(1)=PARTICLE(I)%GRADX(1)-FDUMMY3*DISX*FDUMMY1/DISD - FDUMMY3*DISPX*FDUMMY4/DISPD
      PARTICLE(I)%GRADY(1)=PARTICLE(I)%GRADY(1)-FDUMMY3*DISY*FDUMMY1/DISD - FDUMMY3*DISPY*FDUMMY4/DISPD
      PARTICLE(I)%GRADZ(1)=PARTICLE(I)%GRADZ(1)-FDUMMY3*DISZ*FDUMMY1/DISD - FDUMMY3*DISPZ*FDUMMY4/DISPD
ENDDO


    DISX=PARTICLE(1)%COORX(1)-PARTICLE(2)%COORX(1)                          
    DISY=PARTICLE(1)%COORY(1)-PARTICLE(2)%COORY(1)                          
    DISZ=PARTICLE(1)%COORZ(1)-PARTICLE(2)%COORZ(1)                           
    DISD=SQRT(DISX*DISX + DISY*DISY + DISZ*DISZ)       
      FDUMMY1=DISD-R_CERO
      FDUMMY2=FDUMMY1*FDUMMY1
      ENER2=ENER2+FDUMMY2
      PARTICLE(1)%GRADX(1)=PARTICLE(1)%GRADX(1)-FDUMMY3*DISX*FDUMMY1/DISD
      PARTICLE(1)%GRADY(1)=PARTICLE(1)%GRADY(1)-FDUMMY3*DISY*FDUMMY1/DISD
      PARTICLE(1)%GRADZ(1)=PARTICLE(1)%GRADZ(1)-FDUMMY3*DISZ*FDUMMY1/DISD


    DISX=PARTICLE(NUM_RES)%COORX(1)-PARTICLE(NUM_RES-1)%COORX(1)                          
    DISY=PARTICLE(NUM_RES)%COORY(1)-PARTICLE(NUM_RES-1)%COORY(1)                          
    DISZ=PARTICLE(NUM_RES)%COORZ(1)-PARTICLE(NUM_RES-1)%COORZ(1)                           
    DISD=SQRT(DISX*DISX + DISY*DISY + DISZ*DISZ)       
      FDUMMY1=DISD-R_CERO
      PARTICLE(NUM_RES)%GRADX(1)=PARTICLE(NUM_RES)%GRADX(1)-FDUMMY3*DISX*FDUMMY1/DISD
      PARTICLE(NUM_RES)%GRADY(1)=PARTICLE(NUM_RES)%GRADY(1)-FDUMMY3*DISY*FDUMMY1/DISD
      PARTICLE(NUM_RES)%GRADZ(1)=PARTICLE(NUM_RES)%GRADZ(1)-FDUMMY3*DISZ*FDUMMY1/DISD

      POT_ENER = POT_ENER + A_CONST*ENER2

END SUBROUTINE SPRING


SUBROUTINE KINETIC 
! SUBROUTINE TO COMPUTE THE KINETIC ENERGY
! PEDRO OJEDA,  17/SEP/2021

USE PARAMETERS

REAL(DP)            :: ENER2

	ENER2=0.0D0

DO I=1,NUM_RES
      ENER2 = ENER2 + PARTICLE(I)%VELX(N)**2 + PARTICLE(I)%VELY(N)**2 + PARTICLE(I)%VELZ(N)**2 
ENDDO

      KIN_ENER = 0.5D0*ENER2

END SUBROUTINE KINETIC


SUBROUTINE FORCES
! SUBROUTINE TO CALCULATE THE FORCES DEPENDING ON THE INTERACTIONS DESIRED
! PEDRO OJEDA,  07/MAY/2011

USE PARAMETERS 


	  CALL INITIALIZE_GRAD

          CALL KINETIC

	  !CALL DELTA_MATRIX 

	  CALL SPRING

          CALL LENNARD_JONES


END SUBROUTINE FORCES


SUBROUTINE INITIALIZE
! SUBROUTINE TO INITIALIZE THE COORDINATES, VELOCITIES AND GRADIENT
! PEDRO OJEDA,  07/MAY/2011

USE PARAMETERS

USE Ziggurat

INTEGER             :: P

             DO P=1,NUM_RES
	         PARTICLE(P)%COORX(1)=  (P-15)*6.5D0
	         PARTICLE(P)%COORY(1)=  0.0D0
	         PARTICLE(P)%COORZ(1)=  0.0D0

	         PARTICLE(P)%COORX(2)=  PARTICLE(P)%COORX(1)
	         PARTICLE(P)%COORY(2)=  PARTICLE(P)%COORY(1)
	         PARTICLE(P)%COORZ(2)=  PARTICLE(P)%COORZ(1)

	         PARTICLE_FOLDED(P)%COORX(1)=  PARTICLE(P)%COORX(1)
	         PARTICLE_FOLDED(P)%COORY(1)=  PARTICLE(P)%COORY(1)
	         PARTICLE_FOLDED(P)%COORZ(1)=  PARTICLE(P)%COORZ(1)


	         PARTICLE(P)%VELX(1)=  2.0D0*UNI()-1.0D0
	         PARTICLE(P)%VELY(1)=  2.0D0*UNI()-1.0D0
	         PARTICLE(P)%VELZ(1)=  2.0D0*UNI()-1.0D0

	         PARTICLE(P)%VELX(2)=  PARTICLE(P)%VELX(1)
	         PARTICLE(P)%VELY(2)=  PARTICLE(P)%VELY(1)
	         PARTICLE(P)%VELZ(2)=  PARTICLE(P)%VELZ(1)

	         PARTICLE(P)%GRADX(1)=  0.0D0
	         PARTICLE(P)%GRADY(1)=  0.0D0
	         PARTICLE(P)%GRADZ(1)=  0.0D0

	         PARTICLE(P)%GRADX(2)=  PARTICLE(P)%GRADX(1)
	         PARTICLE(P)%GRADY(2)=  PARTICLE(P)%GRADY(1)
	         PARTICLE(P)%GRADZ(2)=  PARTICLE(P)%GRADZ(1)

	         PARTICLE(P)%MASS=  1.0D0

             ENDDO

             POT_ENER = 0.0
             BOXI = 1.0 / BOXL

END SUBROUTINE INITIALIZE


SUBROUTINE INITIALIZE_GRAD

! SUBROUTINE TO INITIALIZE THE GRADIENT AND POTENTIAL ENERGY
! PEDRO OJEDA,  07/MAY/2011

USE PARAMETERS

INTEGER             :: P

             DO P=1,NUM_RES
	         PARTICLE(P)%GRADX(1)=  0.0
	         PARTICLE(P)%GRADY(1)=  0.0
	         PARTICLE(P)%GRADZ(1)=  0.0
             ENDDO

             POT_ENER = 0.0D0         
             KIN_ENER = 0.0D0           

END SUBROUTINE INITIALIZE_GRAD


